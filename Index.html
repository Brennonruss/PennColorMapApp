<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site Map Drawer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }
        #canvas-container {
            position: relative;
            display: inline-block;
            max-width: 90vw;
            max-height: 80vh;
            width: 800px; /* Fallback width */
            height: 600px; /* Fallback height */
            overflow: auto; /* Enable scrolling */
        }
        #canvas, #annotationCanvas {
            border: 1px solid #000;
            max-width: 100%;
            max-height: 100%;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: top left;
        }
        #tools {
            margin: 20px 0;
            z-index: 10;
            position: relative;
        }
        button, select, input, label {
            margin: 5px;
            padding: 8px 12px;
            font-size: 14px;
        }
        #textInput {
            display: none;
            position: absolute;
            font-size: 16px;
            z-index: 10;
            border: 1px solid #000;
            background: white;
            padding: 5px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        }
        .eraser-cursor {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="10" fill="none" stroke="black" stroke-width="2"/></svg>') 10 10, auto;
        }
        .shape-cursor {
            cursor: crosshair;
        }
        .pan-cursor {
            cursor: grab;
        }
        .pan-cursor:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <h1>EHS Site Navigation Tool</h1>
    <p>Draw on the site map, add text, shapes, or erase marks. Use the tools to change color, size, or switch modes. Press save to downloads when you are done with your marks.</p>
   
    <div id="tools">
        <label for="color">Color:</label>
        <select id="color" onchange="changeColor(this.value)">
            <option value="black" selected>Black</option>
            <option value="red">Red</option>
            <option value="blue">Blue</option>
            <option value="green">Green</option>
            <option value="yellow">Highlighter (Yellow)</option>
        </select>
       
        <button onclick="setMode('draw')">Draw</button>
        <button onclick="setMode('eraser')">Eraser</button>
        <button onclick="setMode('text')">Text</button>
        <button onclick="setMode('pan')">Pan</button>
        <label for="shape">Shape:</label>
        <select id="shape" onchange="setShapeMode(this.value)">
            <option value="none" selected>None</option>
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="line">Line</option>
            <option value="arrow">Arrow</option>
        </select>
        <button onclick="undo()">Undo</button>
       
        <label for="size">Line Size:</label>
        <select id="size" onchange="changeSize(this.value)">
            <option value="2">Small (2px)</option>
            <option value="5" selected>Medium (5px)</option>
            <option value="10">Large (10px)</option>
        </select>
        <label for="fontSize">Font Size:</label>
        <select id="fontSize" onchange="changeFontSize(this.value)">
            <option value="16">Small (16px)</option>
            <option value="24" selected>Medium (24px)</option>
            <option value="32">Large (32px)</option>
        </select>
       
        <button onclick="zoomIn()">Zoom In</button>
        <button onclick="zoomOut()">Zoom Out</button>
        <button onclick="saveImage()">Save to Downloads</button>
    </div>
   
    <div id="canvas-container">
        <img id="sitemap" src="https://i.imgur.com/vxCbTlJ.jpeg" style="display: none;" alt="Site Map" crossorigin="anonymous">
        <canvas id="canvas"></canvas>
        <canvas id="annotationCanvas"></canvas>
    </div>
   
    <input id="textInput" type="text" placeholder="Type text and press Enter">
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const annotationCanvas = document.getElementById('annotationCanvas');
        const annotationCtx = annotationCanvas.getContext('2d');
        const img = document.getElementById('sitemap');
        const textInput = document.getElementById('textInput');
        const canvasContainer = document.getElementById('canvas-container');
       
        let drawing = false;
        let mode = 'draw';
        let shapeMode = 'none';
        let color = 'black';
        let size = 5;
        let fontSize = 24;
        let alpha = 1;
        let textPos = null;
        let shapeStart = null;
        const eraserSize = 20;
        let points = [];
        let history = [];
        let zoomLevel = 1;
        const zoomStep = 0.2;
        const minZoom = 1;
        const maxZoom = 3;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;

        // Load the site map image
        img.onload = function() {
            const maxWidth = window.innerWidth * 0.9;
            const maxHeight = window.innerHeight * 0.8;
            const imgRatio = img.width / img.height;
            let canvasWidth = maxWidth;
            let canvasHeight = maxWidth / imgRatio;
            if (canvasHeight > maxHeight) {
                canvasHeight = maxHeight;
                canvasWidth = maxHeight * imgRatio;
            }
            canvasContainer.style.width = `${canvasWidth}px`;
            canvasContainer.style.height = `${canvasHeight}px`;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            annotationCanvas.width = canvasWidth;
            annotationCanvas.height = canvasHeight;
            updateCanvas();
            saveState();
        };

        // Handle image load errors
        img.onerror = function() {
            console.error("Failed to load image. Ensure the image URL is correct and accessible.");
            alert("Failed to load the site map image. Please check the image URL or host it locally.");
        };

        // Update canvas with zoom
        function updateCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(zoomLevel, zoomLevel);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            ctx.restore();
            annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
            annotationCtx.save();
            annotationCtx.scale(zoomLevel, zoomLevel);
            if (history.length > 0) {
                annotationCtx.drawImage(history[history.length - 1], 0, 0, canvas.width, canvas.height);
            }
            annotationCtx.restore();
            canvas.style.transform = `scale(${zoomLevel})`;
            annotationCanvas.style.transform = `scale(${zoomLevel})`;
            canvasContainer.style.width = `${canvas.width * zoomLevel}px`;
            canvasContainer.style.height = `${canvas.height * zoomLevel}px`;
        }

        // Zoom functions
        function zoomIn() {
            if (zoomLevel < maxZoom) {
                zoomLevel += zoomStep;
                updateCanvas();
            }
        }

        function zoomOut() {
            if (zoomLevel > minZoom) {
                zoomLevel -= zoomStep;
                updateCanvas();
            }
        }

        // Save canvas state for undo
        function saveState() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = annotationCanvas.width;
            tempCanvas.height = annotationCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(annotationCanvas, 0, 0);
            history.push(tempCanvas);
            if (history.length > 50) history.shift();
        }

        // Undo function
        function undo() {
            if (history.length > 1) {
                history.pop();
                annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
                annotationCtx.save();
                annotationCtx.scale(zoomLevel, zoomLevel);
                annotationCtx.drawImage(history[history.length - 1], 0, 0, canvas.width, canvas.height);
                annotationCtx.restore();
            }
        }

        // Tool functions
        function changeColor(newColor) {
            color = newColor;
            alpha = newColor === 'yellow' ? 0.2 : 1;
            if (mode !== 'shape') {
                mode = 'draw';
                annotationCanvas.classList.remove('eraser-cursor', 'shape-cursor', 'pan-cursor');
                annotationCanvas.style.cursor = 'crosshair';
            }
            textInput.style.display = 'none';
        }

        function changeSize(newSize) {
            size = parseInt(newSize);
        }

        function changeFontSize(newSize) {
            fontSize = parseInt(newSize);
        }

        function setMode(newMode) {
            mode = newMode;
            shapeMode = 'none';
            textInput.style.display = 'none';
            annotationCanvas.classList.remove('eraser-cursor', 'shape-cursor', 'pan-cursor');
            if (mode === 'eraser') {
                annotationCanvas.classList.add('eraser-cursor');
            } else if (mode === 'text') {
                annotationCanvas.style.cursor = 'text';
            } else if (mode === 'pan') {
                annotationCanvas.classList.add('pan-cursor');
            } else {
                annotationCanvas.style.cursor = 'crosshair';
            }
        }

        function setShapeMode(newShape) {
            shapeMode = newShape;
            mode = shapeMode !== 'none' ? 'shape' : 'draw';
            textInput.style.display = 'none';
            annotationCanvas.classList.remove('eraser-cursor', 'pan-cursor');
            annotationCanvas.classList.add('shape-cursor');
        }

        // Draw shapes
        function drawShape(start, end) {
            annotationCtx.save();
            annotationCtx.scale(zoomLevel, zoomLevel);
            annotationCtx.beginPath();
            annotationCtx.strokeStyle = color;
            annotationCtx.globalAlpha = alpha;
            annotationCtx.lineWidth = size / zoomLevel;
            if (shapeMode === 'circle') {
                const radius = Math.sqrt((end.x - start.x) ** 2 + (end.y - start.y) ** 2) / zoomLevel;
                annotationCtx.arc(start.x / zoomLevel, start.y / zoomLevel, radius, 0, 2 * Math.PI);
                annotationCtx.stroke();
            } else if (shapeMode === 'square') {
                const width = (end.x - start.x) / zoomLevel;
                const height = (end.y - start.y) / zoomLevel;
                annotationCtx.strokeRect(start.x / zoomLevel, start.y / zoomLevel, width, height);
            } else if (shapeMode === 'line') {
                annotationCtx.moveTo(start.x / zoomLevel, start.y / zoomLevel);
                annotationCtx.lineTo(end.x / zoomLevel, end.y / zoomLevel);
                annotationCtx.stroke();
            } else if (shapeMode === 'arrow') {
                const headLength = 15 / zoomLevel;
                const dx = (end.x - start.x) / zoomLevel;
                const dy = (end.y - start.y) / zoomLevel;
                const angle = Math.atan2(dy, dx);
                annotationCtx.moveTo(start.x / zoomLevel, start.y / zoomLevel);
                annotationCtx.lineTo(end.x / zoomLevel, end.y / zoomLevel);
                annotationCtx.lineTo((end.x / zoomLevel) - headLength * Math.cos(angle - Math.PI / 6), (end.y / zoomLevel) - headLength * Math.sin(angle - Math.PI / 6));
                annotationCtx.moveTo(end.x / zoomLevel, end.y / zoomLevel);
                annotationCtx.lineTo((end.x / zoomLevel) - headLength * Math.cos(angle + Math.PI / 6), (end.y / zoomLevel) - headLength * Math.sin(angle + Math.PI / 6));
                annotationCtx.stroke();
            }
            annotationCtx.restore();
            annotationCtx.globalAlpha = 1;
        }

        // Smooth drawing function
        function drawSmoothLine(x, y) {
            points.push({ x, y });
            if (points.length < 3) return;
            if (points.length > 3) points.shift();
            const avgPoint = points.reduce((acc, p) => ({
                x: acc.x + p.x / points.length,
                y: acc.y + p.y / points.length
            }), { x: 0, y: 0 });
            annotationCtx.save();
            annotationCtx.scale(zoomLevel, zoomLevel);
            annotationCtx.lineWidth = (mode === 'eraser' ? eraserSize : size) / zoomLevel;
            annotationCtx.lineCap = 'round';
            annotationCtx.lineJoin = 'round';
            if (mode === 'eraser') {
                annotationCtx.clearRect((avgPoint.x / zoomLevel) - (eraserSize / zoomLevel) / 2, (avgPoint.y / zoomLevel) - (eraserSize / zoomLevel) / 2, eraserSize / zoomLevel, eraserSize / zoomLevel);
            } else {
                annotationCtx.strokeStyle = color;
                annotationCtx.globalAlpha = alpha;
                annotationCtx.lineTo(avgPoint.x / zoomLevel, avgPoint.y / zoomLevel);
                annotationCtx.stroke();
                annotationCtx.beginPath();
                annotationCtx.moveTo(avgPoint.x / zoomLevel, avgPoint.y / zoomLevel);
            }
            annotationCtx.restore();
        }

        // Drawing and shape handling
        annotationCanvas.addEventListener('mousedown', (e) => {
            const rect = annotationCanvas.getBoundingClientRect();
            const scaleX = annotationCanvas.width / (rect.width * zoomLevel);
            const scaleY = annotationCanvas.height / (rect.height * zoomLevel);
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            if (mode === 'text') {
                textPos = { x, y };
                textInput.style.left = `${e.clientX}px`;
                textInput.style.top = `${e.clientY}px`;
                textInput.style.display = 'block';
                textInput.value = ''; // Clear previous text
                setTimeout(() => {
                    textInput.focus(); // Ensure focus after rendering
                }, 0);
                return;
            }
            if (mode === 'pan') {
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                return;
            }
            drawing = true;
            points = [];
            shapeStart = { x, y };
            annotationCtx.beginPath();
            annotationCtx.moveTo(x / zoomLevel, y / zoomLevel);
        });

        annotationCanvas.addEventListener('mouseup', (e) => {
            if (mode === 'pan') {
                isPanning = false;
                return;
            }
            if (!drawing) return;
            if (mode === 'shape' && shapeStart) {
                const rect = annotationCanvas.getBoundingClientRect();
                const scaleX = annotationCanvas.width / (rect.width * zoomLevel);
                const scaleY = annotationCanvas.height / (rect.height * zoomLevel);
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                drawShape(shapeStart, { x, y });
                saveState();
            } else if (mode !== 'text') {
                saveState();
            }
            drawing = false;
            points = [];
            shapeStart = null;
        });

        annotationCanvas.addEventListener('mouseleave', () => {
            if (drawing && mode !== 'text') {
                saveState();
            }
            drawing = false;
            points = [];
            shapeStart = null;
            isPanning = false;
        });

        annotationCanvas.addEventListener('mousemove', (e) => {
            if (mode === 'pan' && isPanning) {
                const deltaX = e.clientX - panStartX;
                const deltaY = e.clientY - panStartY;
                canvasContainer.scrollLeft -= deltaX;
                canvasContainer.scrollTop -= deltaY;
                panStartX = e.clientX;
                panStartY = e.clientY;
                return;
            }
            if (!drawing || mode === 'text') return;
            const rect = annotationCanvas.getBoundingClientRect();
            const scaleX = annotationCanvas.width / (rect.width * zoomLevel);
            const scaleY = annotationCanvas.height / (rect.height * zoomLevel);
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            if (mode === 'shape' && shapeStart) {
                annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
                if (history.length > 0) {
                    annotationCtx.save();
                    annotationCtx.scale(zoomLevel, zoomLevel);
                    annotationCtx.drawImage(history[history.length - 1], 0, 0, canvas.width, canvas.height);
                    annotationCtx.restore();
                }
                drawShape(shapeStart, { x, y });
            } else {
                drawSmoothLine(x, y);
            }
        });

        // Text input handling
        textInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && textPos) {
                const text = textInput.value.trim();
                if (text) {
                    annotationCtx.save();
                    annotationCtx.scale(zoomLevel, zoomLevel);
                    annotationCtx.font = `${fontSize / zoomLevel}px Arial`;
                    annotationCtx.fillStyle = 'white';
                    annotationCtx.strokeStyle = 'black';
                    annotationCtx.lineWidth = 1 / zoomLevel;
                    annotationCtx.strokeText(text, textPos.x / zoomLevel, textPos.y / zoomLevel);
                    annotationCtx.fillText(text, textPos.x / zoomLevel, textPos.y / zoomLevel);
                    annotationCtx.restore();
                    saveState();
                }
                textInput.value = '';
                textInput.style.display = 'none';
                textPos = null;
                annotationCanvas.style.cursor = 'text';
            }
        });

        // Save function
        function saveImage() {
            textInput.style.display = 'none';
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0);
            tempCtx.drawImage(annotationCanvas, 0, 0);
            const dataURL = tempCanvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'marked_sitemap.png';
            a.click();
        }
    </script>
</body>
</html>




